// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3824.BetaBot.subsystems;

import org.usfirst.frc3824.BetaBot.RobotMap;
import org.usfirst.frc3824.BetaBot.commands.*;
import org.usfirst.frc3824.BetaBot.utilities.HVAGyro;
import org.usfirst.frc3824.BetaBot.utilities.Lidar;
import org.usfirst.frc3824.BetaBot.Constants;

import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * Robot Chassis subsystem class
 */
public class Chassis extends Subsystem
{
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController rightMotorA = RobotMap.chassisRightMotorA;
    private final SpeedController rightMotorB = RobotMap.chassisRightMotorB;
    private final SpeedController leftMotorA = RobotMap.chassisLeftMotorA;
    private final SpeedController leftMotorB = RobotMap.chassisLeftMotorB;
    private final RobotDrive wCDrive4 = RobotMap.chassisWCDrive4;
    private final Compressor compressor = RobotMap.chassisCompressor;
    private final Solenoid transmission = RobotMap.chassisTransmission;
    private final Encoder encoderRight = RobotMap.chassisEncoderRight;
    private final Encoder encoderLeft = RobotMap.chassisEncoderLeft;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private final HVAGyro gyro = RobotMap.chassisGyro;
    private final Lidar lidar = RobotMap.chassisLidar;
    
	// Parameters used for drive while running under PIDControl. The values
	// not set by the controller constructor can be set by a command directly
	private double m_magnitude;

	// Declare the PID Output class prototype
	// (See class at the end of the source file)
	private AnglePIDOutput angleOutput = new AnglePIDOutput();

	// Instantiate the PID controller for driving in the specified direction
	private PIDController angleGyroController = new PIDController(Constants.DRIVETRAIN_DRIVE_STRAIGHT_P, 
	                                                              Constants.DRIVETRAIN_DRIVE_STRAIGHT_I, 
	                                                              Constants.DRIVETRAIN_DRIVE_STRAIGHT_D, 
	                                                              gyro, angleOutput);

	/**
	 * Method to set the default command for the Chassis
	 */
	public void initDefaultCommand()
	{
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new TeleopDrive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	}

	/**
	 * Method to control the drive through the specified joystick
	 */
	public void driveWithJoystick(Joystick stick)
	{
		// Drive with arcade with the Y axis for forward/backward and
		// steer with twist
		// Note: Set the sensitivity to true to decrease joystick at small input
		double twist = stick.getTwist();
		
		// Cube twist to decrease sensitivity
	    twist = twist * twist * twist;
	    
	    // Create a dead zone for forward/backward
	    double moveValue = stick.getY();
	    if (moveValue < 0)
	    	moveValue = -1.0 * (moveValue * moveValue);
	    else
	    	moveValue = moveValue * moveValue;
	    
	    // Drive with arcade control
		wCDrive4.arcadeDrive(moveValue, twist, false);
	}

	/**
	 * Method to configure the gyro based turn/drive straight PID controller
	 */
	public void configurePIDs(double P, double I, double D, double desiredHeading, double tolerance, double power)
	{
		// update the drive power
		m_magnitude = power;

		// Reset Encoder Distance
		resetEncoders();
		
		// Reset the PID controller
		angleGyroController.disable();
		angleGyroController.reset();
		
		// Set the PID gains
		angleGyroController.setPID(P, I, D);
	
		// Set the PID tolerance
		angleGyroController.setAbsoluteTolerance(tolerance);

		// Set the PID desired heading
		angleGyroController.setSetpoint(desiredHeading);
		
		// enable the PID
		angleGyroController.enable();

//		SmartDashboard.putNumber("angle P", angleGyroController.getP());
//		SmartDashboard.putNumber("angle I", angleGyroController.getI());
//		SmartDashboard.putNumber("angle D", angleGyroController.getD());
	}
	
	/**
	 * Method to set the PID heading
	 */
	public void setPID_Heading(double desiredHeading)
	{
		// Set the PID desired heading
		angleGyroController.setSetpoint(desiredHeading);
	}
	
	/**
	 *  Method to get the PID target value (heading)
	 */
	public double getHeadingSetpoint()
	{
		return angleGyroController.getSetpoint();
	}
	
	/**
	 * Method to get the PID target value (heading)
	 */
	public double getPID_Heading()
	{
		return gyro.pidGet();
	}
	
	/**
	 * Method to get the PID error
	 */
	public double getPID_Error()
	{
		return angleGyroController.getError();
	}
	
	/**
	 * Method to disable the angle PId controller
	 */
	public void disablePIDs()
	{
		// disable the PID
		angleGyroController.disable();
	}

	/**
	 * Method to stop the chassis drive motors
	 */
	public void stop()
	{
		// Stop all motors
		wCDrive4.arcadeDrive(0, 0);
		
		// Disable PID Controller
		angleGyroController.disable();
	}

	/**
	 * Method to shift the drive train
	 */
	public void shiftGear(boolean gearHigh)
	{
		// Control the gear shift piston
		transmission.set(gearHigh);
	}
	
	/**
	 * Method to get average encoder distance
	 */
	public double getDistance()
	{
		// Return the maximum encoder distance in case the other is not working
		return (Math.max(encoderLeft.getDistance(), encoderRight.getDistance()));
	}
	
	/**
	 * Method to reset both encoders
	 */
	public void resetEncoders()
	{
		encoderLeft.reset();
		encoderRight.reset();
	}
	
	/**
	 * Method to return the present gyro angle
	 */
	public double getCurrentHeading()
	{
		// Return the gyro angle
		return (gyro.getAngle());
	}

	/**
	 * Method to return a relative gyro angle (between 0 and 360)
	 */
	public double getRelativeAngle()
	{
		// Get the present angle
		double absAngle = gyro.getAngle();

		// Adjust the angle if negative
		while (absAngle < 0.0)
			absAngle += 360.0;

		// Adjust the angle if greater than 360
		while (absAngle >= 360.0)
			absAngle -= 360.0;

		// Return the angle between 0 and 360
		return absAngle;
	}

	/**
	 * Method to reset the chassis gyro
	 */
	public void resetGyro()
	{
		// Reset the gyro (angle goes to zero)
		gyro.reset();
	}

	/**
	 * Method to set the desired chassis speed (magnitude) for PID controlled moves.
	 * Only to be used while controlled by PID controller
	 */
	public void setMagnitude(double magnitude)
	{
		m_magnitude = magnitude;
	}

	/**
	 * Set the chassis drive motor
	 */
	public void setWheelOutput(double rightWheel, double leftWheel)
	{
		rightMotorA.set(rightWheel);
		rightMotorB.set(rightWheel);
		leftMotorA.set(-leftWheel);
		leftMotorB.set(-leftWheel);
	}
	
	/**
	 * Get the Right encoder value
	 */
	public int getRightEncoder()
	{
		return encoderRight.get();
	}
	
	/**
	 * Get the Left encoder value
	 */
	public int getLeftEncoder()
	{
		return encoderLeft.get();
	}
	
	/**
	 * Class declaration for the PIDOutput
	 */
	public class AnglePIDOutput implements PIDOutput
	{
		/**
		 * Virtual function to receive the PID output and set the drive direction 
		 */
		public void pidWrite(double PIDoutput)
		{	
			// Drive the robot given the speed and direction
			// Arcade drive expects a joystick which is negative forward)
			wCDrive4.arcadeDrive(-m_magnitude, PIDoutput);
		}
	}
	
	//-------------------------------------------
	// Lidar commands for Chassis
	//-------------------------------------------
	public double getLidarDistanceCentimeters()
	{
		return lidar.getDistanceCentimeters();
	}
}
