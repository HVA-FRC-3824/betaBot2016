// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3824.BetaBot.subsystems;

import org.usfirst.frc3824.BetaBot.RobotMap;
import org.usfirst.frc3824.BetaBot.commands.*;
import org.usfirst.frc3824.BetaBot.utilities.HVAGyro;
import org.usfirst.frc3824.BetaBot.utilities.Lidar;
import org.usfirst.frc3824.BetaBot.Constants;

import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * Robot Chassis subsystem class
 */
public class Chassis extends Subsystem
{
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController rightMotorA = RobotMap.chassisRightMotorA;
    private final SpeedController rightMotorB = RobotMap.chassisRightMotorB;
    private final SpeedController leftMotorA = RobotMap.chassisLeftMotorA;
    private final SpeedController leftMotorB = RobotMap.chassisLeftMotorB;
    private final RobotDrive wCDrive4 = RobotMap.chassisWCDrive4;
    private final Compressor compressor = RobotMap.chassisCompressor;
    private final Solenoid transmission = RobotMap.chassisTransmission;
    private final Encoder encoderRight = RobotMap.chassisEncoderRight;
    private final Encoder encoderLeft = RobotMap.chassisEncoderLeft;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private final HVAGyro gyro  = RobotMap.chassisGyro;
    private final Lidar   lidar = RobotMap.chassisLidar;
    
	// Parameters used for drive while running under PID Control. The values
	// not set by the controller constructor can be set by a command directly
	private double m_magnitude;

	// Instantiate the PID controller for driving in the specified direction
	private PIDController angleGyroPID = new PIDController(Constants.DRIVETRAIN_DRIVE_STRAIGHT_P, 
	                                                       Constants.DRIVETRAIN_DRIVE_STRAIGHT_I, 
	                                                       Constants.DRIVETRAIN_DRIVE_STRAIGHT_D, 
	                                                       gyro, new AnglePIDOutput());
	
	private PIDController angleEncoderPID_Right = new PIDController(Constants.IMAGE_ANGLE_ENCODER_P, 
                                                                    Constants.IMAGE_ANGLE_ENCODER_I, 
                                                                    Constants.IMAGE_ANGLE_ENCODER_D, 
                                                                    encoderRight, 
                                                                    new SpeedControllerPIDOutputRight());
	
	private PIDController angleEncoderPID_Left = new PIDController(Constants.IMAGE_ANGLE_ENCODER_P, 
	                                                               Constants.IMAGE_ANGLE_ENCODER_I, 
	                                                               Constants.IMAGE_ANGLE_ENCODER_D, 
	                                                               encoderLeft,
	                                                               new SpeedControllerPIDOutputLeft());

	/**
	 * Method to set the default command for the Chassis
	 */
	public void initDefaultCommand()
	{
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new TeleopDrive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	}

	/**
	 * Method to control the drive through the specified joystick
	 */
	public void driveWithJoystick(Joystick stick)
	{
		// Drive with arcade with the Y axis for forward/backward and
		// steer with twist
		// Note: Set the sensitivity to true to decrease joystick at small input
		double twist = stick.getTwist();
		
		// Cube twist to decrease sensitivity
	    twist = twist * twist * twist;
	    
	    // Create a dead zone for forward/backward
	    double moveValue = stick.getY();
	    if (moveValue < 0)
	    	moveValue = -1.0 * (moveValue * moveValue);
	    else
	    	moveValue = moveValue * moveValue;
	    
	    // Drive with arcade control
		wCDrive4.arcadeDrive(moveValue, twist, false);
	}

	/**
	 * Method to configure the gyro based turn/drive straight PID controller
	 */
	public void configureGyroPIDs(double P, double I, double D, 
			                      double desiredHeading, double tolerance, double power)
	{
		// update the drive power
		m_magnitude = power;

		// Reset the PID controller
		angleGyroPID.disable();
		angleGyroPID.reset();
		
		// Reset Encoders for when driving a given distance
		resetEncoders();
		
		// Set the PID gains
		angleGyroPID.setPID(P, I, D);
	
		// Set the PID tolerance
		angleGyroPID.setAbsoluteTolerance(tolerance);

		// Set the PID desired heading
		angleGyroPID.setSetpoint(desiredHeading);
		
		// enable the PID
		angleGyroPID.enable();
	}

	/**
	 * Method to set the PID heading
	 */
	public void setGyroPID_Heading(double desiredHeading)
	{
		// Set the PID desired heading
		angleGyroPID.setSetpoint(desiredHeading);
	}
	
	/**
	 *  Method to get the PID target value (heading)
	 */
	public double getGyroHeadingSetpoint()
	{
		return angleGyroPID.getSetpoint();
	}
	
	/**
	 * Method to get the PID target value (heading)
	 */
	public double getGyroPID_Heading()
	{
		return gyro.pidGet();
	}
	
	/**
	 * Method to get the PID error
	 */
	public double getGyroPID_Error()
	{
		return angleGyroPID.getError();
	}
	
	/**
	 * Method to disable the angle PID controller
	 */
	public void disableAllPIDs()
	{
		// disable the PID
		angleGyroPID.disable();
		angleEncoderPID_Left.disable();
		angleEncoderPID_Right.disable();
	}

	/**
	 * Method to enable the encoder based turn PID controller with default values
	 */
	public void enableEncoderPIDs()
	{
		configureEncoderPIDs(Constants.IMAGE_ANGLE_ENCODER_P, 
		                     Constants.IMAGE_ANGLE_ENCODER_I, 
		                     Constants.IMAGE_ANGLE_ENCODER_D, 0.0, 0.0);
	}
	
	/**
	 * Method to configure the encoder based turn PID controller
	 */
	public void configureEncoderPIDs(double P, double I, double D, 
			                         double desiredEncoderValue, double tolerance)
	{
		// Reset Encoder Distance
		resetEncoders();
		
		// Reset the PID controller
		angleEncoderPID_Left.disable();
		angleEncoderPID_Left.reset();
		angleEncoderPID_Right.disable();
		angleEncoderPID_Right.reset();
		
		// Set the PID gains
		angleEncoderPID_Left.setPID(P,I,D);
		angleEncoderPID_Right.setPID(P,I,D);
	
		// Set the PID tolerance
		angleEncoderPID_Left.setAbsoluteTolerance(tolerance);
		angleEncoderPID_Right.setAbsoluteTolerance(tolerance);
	
		// Set the PID desired set point
		angleEncoderPID_Left.setSetpoint(-desiredEncoderValue);
		angleEncoderPID_Right.setSetpoint(desiredEncoderValue);
		
		// enable the PID
		angleEncoderPID_Left.enable();
		angleEncoderPID_Right.enable();
	}	

	/**
	 * Method to set the PID set point
	 */
	public void setEncoderPID_Setpoint(double desiredEncoderValue)
	{
		// Set the PID desired set point
		angleEncoderPID_Left.setSetpoint(-desiredEncoderValue);
		angleEncoderPID_Right.setSetpoint(desiredEncoderValue);
	}

	/**
	 *  Method to get the PID target value (heading)
	 */
	public double getEncoderSetpoint()
	{
		// Return the Left set point
		// Note: The Right set point should just be the negative of the Left
		return angleEncoderPID_Left.getSetpoint();
	}

	/**
	 * Method to get the PID error
	 */
	public double getEncoderPID_Error()
	{
		// Return the Left PID error 
		return angleEncoderPID_Left.getError();
	}
	
	/**
	 * Method to stop the chassis drive motors
	 */
	public void stop()
	{
		// Stop all motors
		wCDrive4.arcadeDrive(0, 0);
		
		// Disable PID Controller
		angleGyroPID.disable();
	}

	/**
	 * Method to shift the drive train
	 */
	public void shiftGear(boolean gearHigh)
	{
		// Control the gear shift piston
		transmission.set(gearHigh);
	}
	
	/**
	 * Method to get larger of the encoder distances
	 */
	public double getDistance()
	{
		// Return the maximum encoder distance in case the other is not working
		return (Math.max(encoderLeft.getDistance(), encoderRight.getDistance()));
	}
	
	/**
	 * Method to reset both encoders
	 */
	public void resetEncoders()
	{
		encoderLeft.reset();
		encoderRight.reset();
	}
	
	/**
	 * Method to return the present gyro angle
	 */
	public double getCurrentHeading()
	{
		// Return the gyro angle
		return (gyro.getAngle());
	}

	/**
	 * Method to return a relative gyro angle (between 0 and 360)
	 */
	public double getRelativeAngle()
	{
		// Get the present angle
		double absAngle = gyro.getAngle();

		// Adjust the angle if negative
		while (absAngle < 0.0)
			absAngle += 360.0;

		// Adjust the angle if greater than 360
		while (absAngle >= 360.0)
			absAngle -= 360.0;

		// Return the angle between 0 and 360
		return absAngle;
	}

	/**
	 * Method to reset the chassis gyro
	 */
	public void resetGyro()
	{
		// Reset the gyro (angle goes to zero)
		gyro.reset();
	}

	/**
	 * Method to set the desired chassis speed (magnitude) for PID controlled moves.
	 * Only to be used while controlled by PID controller
	 */
	public void setMagnitude(double magnitude)
	{
		m_magnitude = magnitude;
	}

	/**
	 * Set the chassis drive motor
	 */
	public void setWheelOutput(double rightWheel, double leftWheel)
	{
		// Set the right motors for forward direction
		rightMotorA.set(rightWheel);
		rightMotorB.set(rightWheel);
		
		// Set the Left motors for forward direction
		// Note: The Left motors are opposite the Right motors
		leftMotorA.set(-leftWheel);
		leftMotorB.set(-leftWheel);
	}
	
	/**
	 * Get the Right encoder value
	 */
	public int getRightEncoder()
	{
		return encoderRight.get();
	}
	
	/**
	 * Get the Left encoder value
	 */
	public int getLeftEncoder()
	{
		return encoderLeft.get();
	}
	
	/**
	 * Class declaration for the PIDOutput
	 */
	public class AnglePIDOutput implements PIDOutput
	{
		/**
		 * Virtual function to receive the PID output and set the drive direction 
		 */
		public void pidWrite(double PIDoutput)
		{	
			// Drive the robot given the speed and direction
			// Arcade drive expects a joystick which is negative forward)
			wCDrive4.arcadeDrive(-m_magnitude, PIDoutput);
		}
	}
	
	/**
	 * Class declaration for the PIDOutput
	 */
	public class SpeedControllerPIDOutputRight implements PIDOutput
	{
		/**
		 * Virtual function to receive the PID output and set the drive direction 
		 */
		public void pidWrite(double PIDoutput)
		{	
			SmartDashboard.putNumber("SpeedControllerPIDOutputRight: ", PIDoutput);
			rightMotorA.set(PIDoutput);
			rightMotorB.set(PIDoutput);
		}
	}
	
	/**
	 * Class declaration for the PIDOutput
	 */
	public class SpeedControllerPIDOutputLeft implements PIDOutput
	{
		/**
		 * Virtual function to receive the PID output and set the drive direction 
		 */
		public void pidWrite(double PIDoutput)
		{	
			SmartDashboard.putNumber("SpeedControllerPIDOutputLeft: ", -PIDoutput);
			leftMotorA.set(-PIDoutput);
			leftMotorB.set(-PIDoutput);
		}
	}
	
	//-------------------------------------------
	// Lidar commands for Chassis
	//-------------------------------------------
	public double getLidarDistanceCentimeters()
	{
		return lidar.getDistanceCentimeters();
	}
}
