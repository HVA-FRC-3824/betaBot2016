// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3824.BetaBot.subsystems;

import org.usfirst.frc3824.BetaBot.Constants;
import org.usfirst.frc3824.BetaBot.Robot;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.networktables.NetworkTable;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class Targets extends Subsystem
{
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	NetworkTable m_contoursReport;
	NetworkTable m_imageReport;
	NetworkTable m_frameRateReport;

	// Used to clear the target arrays before reading target information
	double[] m_defaultValue = new double[0];

	// Allows off setting the target to compensate for camera angle
	private int m_onTargetX;  // "Center of Image" on the X-axis

	public static class Target
	{
		public int centerX;
		public int centerY;
		public int height;
		public int area;
	}

	public void initDefaultCommand()
	{
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	}

	public Targets()
	{
		m_contoursReport  = NetworkTable.getTable("GRIP/cameraTargets");
		m_frameRateReport = NetworkTable.getTable("GRIP");
		m_onTargetX       = Constants.IMAGE_ON_TARGET_X_POSITION_CENTER;
	}

	/**
	 * ***********************************************************************
	 * Return the position of the target, offset from our desired center point
	 * The return value will be in the range of -2 to 2, where -2 a full image
	 * width to the left of "onTarget" and 2 is a full image width to the right
	 * of "onTarget". In the ideal case of the "onTarget" position being exactly
	 * in the center of the image, then the left edge would be -1 and the right
	 * edge would be 1.
	 */
	public double getTargetOffsetFromCenterNormalized(int whichTarget)
	{
		// if the image is positioned to the right, the robot is too far left.
		// so this return value is flipped
		double positionFromOnTargetX;
		double positionFromOnTargetXNormalized = 0.0;
		Target found_target;

		// System.out.println("In getTargetOffsetFromCenterNormalized: " + whichTarget);

		// get the center of the largest target in view. We are assuming that
		// the
		// largest target is the one we are facing most directly
		found_target = getSelectedTarget(whichTarget);
		if (found_target != null)
		{
			// calculate offset from "OnTarget" in pixels
			positionFromOnTargetX = found_target.centerX - m_onTargetX;

			// convert the offset in pixels to a normalized range where -1 is one half an
			// image width to the left and 1 is one half an image width to the right.
			positionFromOnTargetXNormalized = positionFromOnTargetX / (Constants.IMAGE_WIDTH / 2.0);
		}

		// Return the normalized position from target
		return positionFromOnTargetXNormalized;
	}

	/**
	 * ***********************************************************************
	 * Convert the normalized value into an angle based on the camera's FOV
	 * Technically, this should be a trigonometric function, but we are using a
	 * linear approximation, which is good enough for our purposes. To use the
	 * trig function, we would have to know our distance as well
	 */
	public double getTargetOffsetFromCenterAngle(int whichTarget)
	{
		return getTargetOffsetFromCenterNormalized(whichTarget) * (Constants.CAM_FOV / 2.0);
	}

	/**
	 * ***********************************************************************
	 * Determine if the GRIP image processing pipeline is running on the
	 * RaspberryPi. We assume that if the frame rate is non-zero, then the
	 * pipeline is running. If the frame rate is 0, it is not running
	 */
	public boolean isImageProcessingRunning()
	{
		return (m_frameRateReport.getNumber("cameraFrameRate", 0.0) > 0);
	}

	/**
	 * ***********************************************************************
	 * Display data values on the smart dashboard
	 */
	public void updateSmartDashboard(Target target)
	{
		SmartDashboard.putBoolean("Image Processing Running", isImageProcessingRunning());
		SmartDashboard.putNumber("Targets FrameRate",         m_frameRateReport.getNumber("cameraFrameRate", 0.0));

		if (target != null)
		{
			SmartDashboard.putNumber("TargetPixel_X", target.centerX);
			SmartDashboard.putNumber("TargetPixel_Y", target.centerY);
			SmartDashboard.putNumber("TargetHeight", target.height);
		}
		else
		{
			SmartDashboard.putNumber("TargetPixel_X", -1);
			SmartDashboard.putNumber("TargetPixel_Y", -1);
			SmartDashboard.putNumber("TargetHeight",  -1);
		}
	}

	/**
	 * ***********************************************************************
	 * Calculate the center of the largest target in the list of targets NOTE: I
	 * THINK this will always be the first object in the array, but until this
	 * can be confirmed, need to do this calculation
	 */
	public Target getLargestTarget()
	{
		double[] centerXs = m_contoursReport.getNumberArray("centerX", m_defaultValue);
		double[] centerYs = m_contoursReport.getNumberArray("centerY", m_defaultValue);
		double[] areas    = m_contoursReport.getNumberArray("area",    m_defaultValue);
		double[] widths   = m_contoursReport.getNumberArray("width",   m_defaultValue);
		double[] heights  = m_contoursReport.getNumberArray("height",  m_defaultValue);
		double maxArea    = 0.0;
		int maxAreaIndex  = -1;
		Target largest_target = new Target();

		try
		{
			// Loop through all targets
			for (int areaIndex = 0; areaIndex < areas.length; areaIndex++)
			{
				// Determine if the area is the largest
				if (areas[areaIndex] > maxArea)
				{
					// Remember the maximum area index
					maxAreaIndex = areaIndex;

					// Update the new maximum area
					maxArea = areas[areaIndex];
				}
			}

			// Determine if a target area was found
			if (maxAreaIndex >= 0)
			{
				// remember the X position of the maximum area target
				largest_target.centerX = (int) centerXs[maxAreaIndex];
				largest_target.centerY = (int) centerYs[maxAreaIndex];
				largest_target.height  = (int) heights[maxAreaIndex];
				largest_target.area    = (int) (widths[maxAreaIndex] * heights[maxAreaIndex]);
			}
			else
			{
				// No target found so return center
				largest_target = null;
			}
		}
		catch (Exception e)
		{
			System.out.println("Exception getLargestTarget: " + e);
			largest_target = null;
		}

		updateSmartDashboard(largest_target);

		// return the X position of the maximum area target
		return largest_target;
	}

	/**
	 * Method to select the specified target when there are multiple targets
	 */
	public Target getSelectedTarget(int whichTarget)
	{
		int target_index    = 0;
		double[] centerXs   = m_contoursReport.getNumberArray("centerX", m_defaultValue);
		double[] centerYs   = m_contoursReport.getNumberArray("centerY", m_defaultValue);
		double[] areas      = m_contoursReport.getNumberArray("area",    m_defaultValue);
		double[] widths     = m_contoursReport.getNumberArray("width",   m_defaultValue);
		double[] heights    = m_contoursReport.getNumberArray("height",  m_defaultValue);
		Target found_target = new Target();

		System.out.println("In getSelectedTarget: Targets" + areas.length);

		try
		{
			// Determine the number of found targets
			if (areas.length == 1)
			{
				System.out.println("areas.length == 1");

				// Only one target so return X center
				target_index = 0;
			}
			else if (areas.length == 2)
			{
				System.out.println("areas.length == 2");

				// ----- TWO TARGETS DETECTED -------
				switch (whichTarget)
				{
				case 0: // LEFT - take the left target
					if (centerXs[0] < centerXs[1])
						target_index = 0;
					else
						target_index = 1;
					break;

				case 1: // CENTER - take the LARGEST target
					if (areas[0] > areas[1])
					{
						target_index = 0;
					}
					else
					{
						target_index = 1;
					}
					break;

				case 2: // RIGHT - take the right target
					if (centerXs[0] >= centerXs[1])
						target_index = 0;
					else
						target_index = 1;
					break;
				}
			}
			else if (areas.length == 3)
			{
				System.out.println("areas.length == 3");

				// ----- THREE TARGETS DETECTED -------
				switch (whichTarget)
				{
				case 0: // LEFT - take the left target
					if ((centerXs[0] < centerXs[1]) && (centerXs[0] < centerXs[2]))
						target_index = 0;
					else if ((centerXs[1] < centerXs[0]) && (centerXs[1] < centerXs[2]))
						target_index = 1;
					else
						target_index = 2;
					break;

				case 1: // CENTER - take the LARGEST target
					if ((areas[0] >= areas[1]) && (areas[0] >= areas[2]))
						target_index = 0;
					else if ((areas[1] >= areas[0]) && (areas[1] >= areas[2]))
						target_index = 1;
					else
						target_index = 2;
					break;

				case 2: // RIGHT - take the right target
					if ((centerXs[0] >= centerXs[1]) && (centerXs[0] >= centerXs[2]))
						target_index = 0;
					else if ((centerXs[1] >= centerXs[0]) && (centerXs[1] >= centerXs[2]))
						target_index = 1;
					else
						target_index = 2;
					break;
				}
			}
			else
			{
				// No target found so return center
				return null;
			}

			System.out.println("   centerXs Length:" + centerXs.length);
			System.out.println("   centerYs Length:" + centerYs.length);
			System.out.println("   widths Length:"   + widths.length);
			System.out.println("   heights Length:"  + heights.length);
			found_target.centerX = (int) centerXs[target_index];
			found_target.centerY = (int) centerYs[target_index];
			found_target.height  = (int) heights[target_index];
			found_target.area    = (int) (widths[target_index] * heights[target_index]);

			System.out.println("****** target_index = " + target_index);
			System.out.println("       area = " + found_target.area);
		}
		catch (Exception e)
		{
			found_target = null;
			System.out.println("Exception getSelectedTarget: " + e);
		}

		updateSmartDashboard(found_target);

		return found_target;
	}

	/**
	 * Method to return the distance from the largest target based on the target area
	 */
	public double getDistanceFromLargestTarget()
	{
		Target found_target;
		double area;
		double distanceFromTarget = -1.0;

		found_target = getLargestTarget();

		// Ensure a target was identified
		if (found_target != null)
		{
			// get the area of the selected target
			area = found_target.area;

			// y = 9E-06x2 - 0.1589x + 583.49
			distanceFromTarget = (9e-6 * area * area) - (0.1589 * area) + 583.49;
		}

		// Return the distance from the target
		return distanceFromTarget;
	}

	/**
	 * Method to return the distance from the specified target based on the target area
	 */
	public double getDistanceFromTarget(int whichTarget)
	{
		Target found_target;
		double area;
		double distanceFromTarget = -1.0;

		// get the area of the selected target
		found_target = getSelectedTarget(whichTarget);

		// Ensure a target was identified
		if (found_target != null)
		{
			area = found_target.area;

			// y = 9E-06x2 - 0.0896x + 267.23
			distanceFromTarget = (9e-6 * area * area) - (0.0896 * area) + 267.23;
		}

		// Return the distance from the target
		return distanceFromTarget;
	}
}
